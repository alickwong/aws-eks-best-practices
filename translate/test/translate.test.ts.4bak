import {
  BedrockRuntimeClient,
  InvokeModelCommand,
  InvokeModelCommandInput, InvokeModelWithResponseStreamCommand,
  InvokeModelWithResponseStreamCommandInput
} from "@aws-sdk/client-bedrock-runtime";
import * as fs from 'fs';
import * as path from 'path';
import * as retry from 'async-retry';

let lang = 'zh'
const bedrock = new BedrockRuntimeClient();

jest.setTimeout(1000000000);

function getNote(): string {
  return "!!! note\n" +
    "    This page's content was created using the Large Language Model (Claude 3) and is based on the English version." +
    "    In case of discrepancy, the English version shall prevail. " +
    "\n";
}

function getPrompt(chunk: string) {
  // If add two \n in this code `${chunk}\nAssistant:`, all result will have one more line
  const prompt = `\n\nHuman: 
    Translate the following the text in a markdown file to simplified Chinese, Follow these requirements:
    - For any technical terms or proper nouns, please keep them in the original English. This includes but is not limited to names of technologies, protocols, software, APIs, and technical concepts.
    - if the line consist ![any text] it means images, do not translate
    - Always reply like this: "Your translation is:\n[translation text]"
    - Do not try to change/ fix the markdown symbol.
    - Only return the translated text.
    - Ensuring a formal tone and using industry-specific terms
    - Do not add extra information, such as extra titles, only need to translate
    - If the text only have a image markdown tag, ONLY translate the text inside \[\] symbol, do not add extra titles
    - Do not translate the text inside \`\` symbol
    Here is the text need to be translated:\n${chunk}\nAssistant:`;

  return prompt;
}

async function bedrockStreamingApi(chunk: string) {
  let prompt = getPrompt(chunk)
  let payload = {
    "anthropic_version": "bedrock-2023-05-31",
    "max_tokens": 100000,
    "temperature": 0,
    "top_k": 1,
    "messages": [
      {
        "role": "user",
        "content": [{"type": "text", "text": prompt}]
      }
    ],
    // "sessionState": sessionState
  };
  const params: InvokeModelWithResponseStreamCommandInput = {
    // modelId: "anthropic.claude-3-sonnet-20240229-v1:0",
    modelId: "anthropic.claude-3-haiku-20240307-v1:0",
    body: JSON.stringify(payload),
    contentType: "application/json"
  };
  const command = new InvokeModelWithResponseStreamCommand(params);
  const res = await bedrock.send(command);
  const chunks: string[] = []

  if (res) {
    for await (const event of res?.body ?? []) {
      if (event.chunk && event.chunk.bytes) {
        const translatedChunk = JSON.parse(Buffer.from(event.chunk.bytes).toString("utf-8"));
        if (translatedChunk) {
          console.log(`received for i: ${JSON.stringify(translatedChunk.delta)}`);
        }

      } else if (
        event.internalServerException ||
        event.modelStreamErrorException ||
        event.throttlingException ||
        event.validationException
      ) {
        console.error(event);
        break;
      }
    }
    console.log({
      prompt: prompt,
      completion: chunks.join(''),
    });

    return chunks.join('').replace(/^.*\n/, '');;
  }

  return;
}

async function simplifiedTranslateFile(filePath: string) {
  console.log(`start translating ${filePath}`);
  let englishText = '';
  englishText += getNote();
  englishText += fs.readFileSync(filePath, 'utf-8');
  let translatedText = await bedrockStreamingApi(englishText);

  if (translatedText) {
    let nameArr = path.basename(filePath).split('.');
    const outputPath = path.join(path.dirname(filePath), nameArr[0] + '.' + lang + '.' + nameArr[1]);
    fs.writeFileSync(outputPath, translatedText);
    console.log(`Translated ${filePath}`);
  } else {
    console.log(`Translate failed for ${filePath}`);
  }
}

async function getFiles(dirPath: string): Promise<string[]> {
  let files: string[] = [];

  const items = await fs.promises.readdir(dirPath);

  for (const item of items) {
    const itemPath = path.join(dirPath, item);
    const stat = await fs.promises.stat(itemPath);

    if (stat.isDirectory()) {
      const subDirFiles = await getFiles(itemPath);
      files = files.concat(subDirFiles);
    } else {
      files.push(itemPath);
    }
  }

  return files;
}

async function translateDirectory(inputDir: string, outputDir: string): Promise<void> {
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, {recursive: true});
  }

  const files = await getFiles(inputDir);
  console.log('testtt', inputDir, files);

  const batchSize = 5;
  for (let i = 0; i < files.length; i += batchSize) {
    const batch = files.slice(i, i + batchSize);
    const promises = batch.map(async (file) => {
      const fileName = path.basename(file);
      const extension = path.extname(fileName);
      const dotCount = fileName.split('.').length - 1;

      if (extension === '.md' && dotCount === 1) {
        await simplifiedTranslateFile(file);
      }
    });

    await Promise.all(promises);
  }
}

test('Directory Translate Files', async () => {
  const inputDir = '../content/scalability';
  const outputDir = '../content/scalability';
  // const inputDir = '../content/karpenter';
  await translateDirectory(inputDir, outputDir);  // const outputDir = '../content/scalability
});

test('Single File Translate Files', async () => {
  // Single File Translate
  const inputDir = '../content/scalability/docs/quotas.md';
  const outputDir = '../content/scalability/docs';
  await simplifiedTranslateFile(inputDir);
});

test('Streaming API Test', async () => {
  let result = await bedrockStreamingApi('Limit dynamic admission webhooks per resource¶\n' +
    'Dynamic Admission Webhooks include admission webhooks and mutating webhooks. They are API endpoints not part of the Kubernetes Control Plane that are called in sequence when a resource is sent to the Kubernetes API. Each webhook has a default timeout of 10 seconds and can increase the amount of time an API request takes if you have multiple webhooks or any of them timeout.\n' +
    '\n' +
    'Make sure your webhooks are highly available—especially during an AZ incident—and the failurePolicy is set properly to reject the resource or ignore the failure. Do not call webhooks when not needed by allowing --dry-run kubectl commands to bypass the webhook.');
  console.log(result);
});

